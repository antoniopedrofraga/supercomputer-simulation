%Copyright 2014 Jean-Philippe Eisenbarth
%This program is free software: you can 
%redistribute it and/or modify it under the terms of the GNU General Public 
%License as published by the Free Software Foundation, either version 3 of the 
%License, or (at your option) any later version.
%This program is distributed in the hope that it will be useful,but WITHOUT ANY 
%WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
%PARTICULAR PURPOSE. See the GNU General Public License for more details.
%You should have received a copy of the GNU General Public License along with 
%this program.  If not, see <http://www.gnu.org/licenses/>.

%Based on the code of Yiannis Lazarides
%http://tex.stackexchange.com/questions/42602/software-requirements-specification-with-latex
%http://tex.stackexchange.com/users/963/yiannis-lazarides
%Also based on the template of Karl E. Wiegers
%http://www.se.rit.edu/~emad/teaching/slides/srs_template_sep14.pdf
%http://karlwiegers.com
\documentclass{scrreprt}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Software Requirement Specification},    % title
    pdfauthor={Jean-Philippe Eisenbarth},                     % author
    pdfsubject={TeX and LaTeX},                        % subject of the document
    pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=purple,        % color of external links
    linktoc=page            % only page is linked
}%
\def\myversion{1.0 }
\date{}
%\title{%

%}
\usepackage{hyperref}
\begin{document}

\begin{flushright}
    \rule{16cm}{5pt}\vskip1cm
    \begin{bfseries}
        \Huge{SOFTWARE REQUIREMENTS\\ SPECIFICATION}\\
        \vspace{1.9cm}
        for\\
        \vspace{1.9cm}
        Simulated Computing System\\
        \vspace{1.9cm}
        \LARGE{Version \myversion}\\
        \vspace{1.9cm}
        Prepared by António Pedro Fraga\\
        \vspace{1.9cm}
        Cranfield University\\
        \vspace{1.9cm}
        \today\\
    \end{bfseries}
\end{flushright}

\tableofcontents

\chapter{Introduction}

\section{Purpose}
This document is a Software Requirements Specification of a project developed under under two modules, \textbf{Software Testing and Quality Assurance} and  \textbf{Requirements Analysis and System Design} at \textbf{Cranfield University}. It describes the implementation of a computing control system. This document is primarily intended to be proposed to the IT department for their approval and serve as a reference for the development of the system.


\section{Project Scope}

\par The software is a \textbf{simulator of a job control system}. It will be used by the IT department of Cranfield University so that it can explore different strategies to their current implementation. 
\par The developed software will include an \textbf{User Friendly Interface}, so that it can be used more easily. The simulation shall be capable of regulate its \textbf{inputs} so that it can compute a set of outputs.
\par The resulting application shall be a \textbf{reliable} and \textbf{efficient}, \textbf{cross-platform} program.

\section{Standards}

\subsection{Documentation}

\par This document follows the \textbf{Requirements Specifications template (IEEE Std 830-1998)}, selecting the most relevant topics for its scope. The \textbf{Test Plan} document shall follow the \textbf{IEEE 829 format}.

\subsubsection{Technical Documentation}

\par Good technical documentation is a key to the project scalability, helping future developers to have a better understanding of the whole project structure.
\par The project shall contain, at least, a \textbf{README} file created in its \textbf{GitHub} page. This file must include some topics:

\begin{itemize}
\item Tests status
\item Line coverage information
\item Project name
\item Description
\item Technologies
\item Informations about the development environment set up
\item Structure information (ex: location of important files)
\end{itemize}

\par The software shall also include documentation about the developed methods and its structure. All methods shall contain at least:

\begin{itemize}
\item Method name
\item Description
\item Arguments (type \& small description)
\item Return (type \& small description)
\end{itemize}

\subsection{Version Control}

This project shall have a \textbf{version control} system based on \textbf{GitHub}. The repository shall contain \textbf{two} main branches:

\begin{itemize}
\item Deployment - Containing a product release history
\item Development - Containing a merge of the newly developed features
\end{itemize}

\par A branch shall be created every time a new feature starts its development.
\par The \textbf{feature} branch shall be merged with the \textbf{Development} branch every time its development has came to an end.
\par The \textbf{Development} branch shall be merged with the \textbf{Deployment} branch every time a new version of the product is released.

\subsection{Naming}
A naming convention is a set of rules for selecting the character sequence to the identifiers of variables, classes, modules or implemented methods. There are different patterns that can be adopted when defining a convention:

\begin{itemize}
\item \textbf{PascalCase (UpperCamelCase)} - the first letter of each word composing the identifier is capitalized.
\item \textbf{Snake_case} - the elements of the compound words are separated with one underscore character and no spaces. The initial character of each element is lowercased, except for the first character, that can be both upper or lower case (‘snake_case’ or ‘Snake_
case’).
\end{itemize}

\subsubsection{Files}

\par C++ code shall be stored in \textbf{.cpp} files, whereas functions and variables definitions should be carried by \textbf{header} or \textbf{.h} files. File names shall follow the \textbf{snake_case} convention with the first character being uncapitalised.

\subsubsection{White spacing}

\par Blank lines improve readability by creating sections of code logically related. 
\par Every statement shall be correctly indented. The indentation increases by a \textbf{tab} if the previous line is:
\begin{itemize}
\item \textbf{\{} a left brace
\item \textbf{[} a left bracket
\item \textbf{(} a left parenthesis
\end{itemize}
The matching closing token must be the first in a line, restoring the previous indentation.
Blank spaces shall be used in some circumstances:

\begin{center}
    \begin{tabular}{|p{8cm}|p{6cm}|}
        \hline
	    Description & Example\\
        \hline
	    A keyword followed by the \textbf{left parenthesis} should be separated by a whitespace. \newline For example, there should be a space after an if or a while keyword. &  – while (true) \{ ... \newline – return (1 + 1); \newline – if (job.is_short()) \{ ... \\
	    \hline
	    The method \textbf{return type} shall be followed by a white space. & \textbf{double} get_usage_price() \\
	    \hline
	  	Every \textbf{comma} shall be followed by a line break or a white space. & insert_state(i\textbf{, }j\textbf{, }job); \\
	  	\hline
	  	Every \textbf{semicolon} at the end of a statement shall be followed with a line break. & i++\textbf{;}\newline j++\textbf{;}\\
	    \hline
	    Every \textbf{semicolon} in the control of a loop shall be followed by a white space. & for (int i = 0\textbf{; } i $<$ v.size()\textbf{; }i++) \{ ...\\
	    \hline
    \end{tabular}
\end{center}

\subsubsection{Classes}

\par Classes should be defined as names written in the \textbf{PascalCase} convention. Acronyms and abbreviations should be avoided, unless the abbreviation is widely used.

\subsubsection{Methods}

\par The name of each method shall start with a verb in the infinite form, being a \textbf{verb-name} pair. This name shall be written in \textbf{snake_case}. It should be self-explanatory and concise.

\par \textbf{Examples:} is_short(), is_medium, get_name(), get_price()

\subsubsection{Variables}

\par Variables shall be written in \textbf{snake_case}. The use of descriptive names is required, avoiding single characters names, except for loops. Abbreviations shall be avoided as well. All variables must be declared in the top of the method body, whit a blank line between this declaration and the rest of the method, forming an \textbf{instantiation block}. The names (\textbf{i}, \textbf{j}, \textbf{k}) are reserved for iteration purposes. 
\par Constant declarations must follow a \textbf{SNAKE_CASE} convention. The developer shall write them entirely with capital characters.


\subsubsection{Branches}

\par Branches shall be written in \textbf{snake_case}. Every branch shall have a name related with the developed feature. 

\chapter{Overall Description}

\section{Product Perspective}
\par The product is a stand-alone system. This system shall contain \textbf{at least} 128 nodes with \textbf{at least} 16 cores per node. It will be used by a set of simulated users that can be classified as:

\begin{itemize}
\item IT support
\item Researchers
\item Students
\end{itemize}

\par The IT support simulated users have an \textbf{infinite} budget, therefore is permitted to them to run as many jobs as they like. In other hand, the Students shall have a constant budget, which is a smaller amount compared to the Researchers budget. This budget confines the amount of jobs that a user is permitted to run. The system usage has a price per core, that shall be decreased from the simulated budget every second.
\par The users can use the system by submitting jobs. This jobs have a two main characteristics, the amount of time that will use the system (running time), and the amount of system cores it will use. Thus, there are four types of jobs:

\begin{itemize}
\item Short - can take up to 2 nodes for no more than 1 hour. 10\% of the machine is reserved for these kind of jobs.
\item Medium - can take up for 10\% of the total number of cores for no more than 8 hours. 30\% of the system is reserved for this queue.
\item Large - can take up for 50\% of the total number of cores for no more than 16 hours. 70\% of the system is reserved for this queue.
\item Huge - can only run from 1700 of Friday to 0900 of Monday, reserving the whole machine. During this time, no other job can be executed.
\end{itemize}

\par Every time a simulated user submits a job, a scheduler shall define whenever that job is going to run. This scheduler manages the amount of computational resources at every second.


\section{Product Functions}
An user of the simulation shall be able to regulate a set of the inputs:

\begin{itemize}
\item Number of jobs \footnotemark
\item Number of users \footnotemark[\value{footnote}]
\item Student Budget \footnotemark[\value{footnote}]
\item Researcher Budget \footnotemark[\value{footnote}]
\item Simulation date - the date when the first job submission is done.
\item Requests span - the time span that a job can be submitted in.
\item Number of nodes
\item Number of cores
\end{itemize}

The simulation shall produce a set of outputs regarding:

\begin{itemize}
\item The number of jobs processed in each queue (throughput) per week
\item The actual number of machine-hours consumed by user jobs
\item The resulting price paid by the users
\item The average wait time in each queue
\item The average turnaround time ratio, i.e. the time from placing the job request to completion of the job divided by the actual runtime of the job
\item The economic balance of the centre, calculated by subtracting from the actual price the operating costs
\end{itemize}

\footnotetext{The user shall decide whether this number is randomly defined following a linear distribution or is a constant value.}


\section{User Documentation}

\par The software shall have an \textbf{User Manual}, indicating which features can be explored. The manual should include a \textbf{screen-shot} of the \textbf{User Interface} along with an explanation of every possible action. The screen shot shall clearly indicate which \textbf{spin box} value is related to each input. The manual shall also include an explanation of the simulation output. Every output value shall be clarified, enlightening the user about its meaning.

\section{Assumptions and Dependencies}

\par For simplification purposes, it is assumed that the scheduler works on a basis of a \textbf{First Come, First Served} methodology. 
\par The running time of each job and the interval between job submissions follow \textbf{exponential distributions}.
\par The number of cores each job uses is generated following a linear distribution. The limits are defined according to each job type:
\begin{itemize}
\item Short: 1 core to 2 nodes of total cores
\item Medium: 2 nodes to 10\% of total cores
\item Large: 10\% nodes to 50\% of total cores
\item Huge: total number of cores
\end{itemize}
\par Every time an input is defined randomly, it follows a linear distribution.
\par It is assumed that only huge jobs can run during weekends, no other queue can be active during this period.


\chapter{System Features}
$<$This template illustrates organizing the functional requirements for the 
product by system features, the major services provided by the product. You may 
prefer to organize this section by use case, mode of operation, user class, 
object class, functional hierarchy, or combinations of these, whatever makes the 
most logical sense for your product.$>$

\section{System Feature 1}
$<$Don’t really say “System Feature 1.” State the feature name in just a few 
words.$>$

\subsection{Description and Priority}
$<$Provide a short description of the feature and indicate whether it is of 
High, Medium, or Low priority. You could also include specific priority 
component ratings, such as benefit, penalty, cost, and risk (each rated on a 
relative scale from a low of 1 to a high of 9).$>$

\subsection{Stimulus/Response Sequences}
$<$List the sequences of user actions and system responses that stimulate the 
behavior defined for this feature. These will correspond to the dialog elements 
associated with use cases.$>$

\subsection{Functional Requirements}
$<$Itemize the detailed functional requirements associated with this feature.  
These are the software capabilities that must be present in order for the user 
to carry out the services provided by the feature, or to execute the use case.  
Include how the product should respond to anticipated error conditions or 
invalid inputs. Requirements should be concise, complete, unambiguous, 
verifiable, and necessary. Use “TBD” as a placeholder to indicate when necessary 
information is not yet available.$>$

$<$Each requirement should be uniquely identified with a sequence number or a 
meaningful tag of some kind.$>$

REQ-1:	REQ-2:

\section{System Feature 2 (and so on)}


\chapter{Other Nonfunctional Requirements}

\section{Performance Requirements}

$<$If there are performance requirements for the product under various 
circumstances, state them here and explain their rationale, to help the 
developers understand the intent and make suitable design choices. Specify the 
timing relationships for real time systems. Make such requirements as specific 
as possible. You may need to state performance requirements for individual 
functional requirements or features.$>$

\section{Software Quality Attributes}
$<$Specify any additional quality characteristics for the product that will be 
important to either the customers or the developers. Some to consider are: 
adaptability, availability, correctness, flexibility, interoperability, 
maintainability, portability, reliability, reusability, robustness, testability, 
and usability. Write these to be specific, quantitative, and verifiable when 
possible. At the least, clarify the relative preferences for various attributes, 
such as ease of use over ease of learning.$>$



\chapter{Appendixes}

\section{Appendix B: Analysis Models}
$<$Optionally, include any pertinent analysis models, such as data flow 
diagrams, class diagrams, state-transition diagrams, or entity-relationship 
diagrams.$>$



\end{document}
